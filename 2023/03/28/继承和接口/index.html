<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="子类和父类继承在一般类（父类）的基础上添加新的成员属性和成员方法，产生新的类（子类) 继承是面向对象的第二大特征，是软件重用方面的重要功能。 类图表示 子类指向父类 关系 is a父类和子类之间是“is-a”的关系，即子类是父类的一个特例。 父类：抽取一类事物的共同属性和方法。 子类：添加特殊事物的特殊属性和方法。 语法[修饰符（默认或public）]  class  子类名  extends">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/03/28/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="子类和父类继承在一般类（父类）的基础上添加新的成员属性和成员方法，产生新的类（子类) 继承是面向对象的第二大特征，是软件重用方面的重要功能。 类图表示 子类指向父类 关系 is a父类和子类之间是“is-a”的关系，即子类是父类的一个特例。 父类：抽取一类事物的共同属性和方法。 子类：添加特殊事物的特殊属性和方法。 语法[修饰符（默认或public）]  class  子类名  extends">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680158157703.png">
<meta property="og:image" content="http://example.com/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680597849567.png">
<meta property="og:image" content="http://example.com/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680598351702.png">
<meta property="og:image" content="http://example.com/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680760720484.png">
<meta property="og:image" content="http://example.com/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1681201330812.png">
<meta property="article:published_time" content="2023-03-28T07:36:38.545Z">
<meta property="article:modified_time" content="2023-05-30T23:23:55.585Z">
<meta property="article:author" content="missbyebye">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680158157703.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-继承和接口" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/28/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time class="dt-published" datetime="2023-03-28T07:36:38.545Z" itemprop="datePublished">2023-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="子类和父类"><a href="#子类和父类" class="headerlink" title="子类和父类"></a>子类和父类</h2><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在一般类（父类）的基础上添加新的成员属性和成员方法，产生新的类（子类)</p>
<p>继承是面向对象的第二大特征，是软件重用方面的重要功能。</p>
<p>类图表示 子类指向父类</p>
<h5 id="关系-is-a"><a href="#关系-is-a" class="headerlink" title="关系 is a"></a>关系 is a</h5><p>父类和子类之间是“<strong>is-a</strong>”的关系，即子类是父类的一个特例。</p>
<p>父类：抽取一类事物的共同属性和方法。</p>
<p>子类：添加特殊事物的特殊属性和方法。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>[修饰符（默认或public）]  class  子类名  extends  父类名</p>
<h4 id="子类的继承性"><a href="#子类的继承性" class="headerlink" title="子类的继承性"></a>子类的继承性</h4><p>由父类的属性和方法前面的<strong>访问控制修饰符</strong>，以及子类和父类<strong>是否同包</strong>来决定子类能否继承父类的属性和方法。</p>
<ul>
<li>默认成员变量和成员方法的继承性</li>
</ul>
<p>默认的成员变量和成员方法可以被<strong>同包</strong>中的其他类访问</p>
<ul>
<li>被protected修饰的成员变量和成员方法的继承性</li>
</ul>
<p>被proteced修饰的成员变量和成员方法可以被<strong>同包中的其他类</strong>（当然包括同包中的子类）访问，也可以被<strong>不同包中的子类</strong>访问。也即，子类不管与父类是否同包，都可以继承父类中被protected修饰的成员变量和成员方法</p>
<p><em>布尔型 读取方法不是 get而是is</em></p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object类是所有类的祖先，即使定义没有写extends Object，也等效于写了。</p>
<p>String toString()：返回该对象的字符串表示。包名.类名+@+地址</p>
<p>输出对象的toString()，可直接输出对象名</p>
<p>所有子类覆盖此方法。</p>
<p>Object的toString()方法通常不能满足要求，子类需要覆盖该方法，返回一个描述子类对象的字符串。</p>
<p>Object clone()：将当前对象克隆。</p>
<p>public boolean equals(Object c);  (对象调用跟c比)</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>在生成子类对象的时候，会包含一个父类对象，<strong>super表示父类对象的引用。</strong></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li>调用父类的构造方法</li>
</ol>
<p>super（）</p>
<p>super(参数列表)</p>
<p>注意：调用父类构造方法的语句，必须放在第一句</p>
<ol start="2">
<li>调用父类的成员属性或成员方法</li>
</ol>
<p>super.成员属性</p>
<p>super.成员方法(参数列表)</p>
<h4 id="构造方法链"><a href="#构造方法链" class="headerlink" title="构造方法链"></a>构造方法链</h4><p>一个子类的对象内部包含父类的对象。</p>
<p>问题：如果子类的构造方法中没有显式的调用父类的构造方法，则嵌在子类内部的父类对象如何构建？</p>
<p>如果子类构造方法没有显式的调用父类的构造方法，则编译器自动添加super()语句，调用父类的构造方法，创建父类对象。</p>
<p>当一个父类中有有参的构造方法时，一定显式添加一个无参的构造方法。<em>避免子类构造方法因没有对应构造方法报错</em></p>
<p>如果一个子类的父类还有父类，……，当构造一个子类的对象时，会从最高级的父类开始，依次调用各个类的构造方法，直到最后一个构造方法被调用，形成构造方法链。</p>
<p>例子：下面是三个类的继承关系，在创建Faculty对象的时候，会先调用Person的构造方法，创建Person对象，再调用Employee的构造方法，创建Employee对象，最后调用Faculty的构造方法，创建Faculty对象。</p>
<p><img src="/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680158157703.png" alt="1680158157703"></p>
<h4 id="调用父类的方法"><a href="#调用父类的方法" class="headerlink" title="调用父类的方法"></a>调用父类的方法</h4><p>如果子类添加的成员变量和成员方法，与从父类继承而来的成员变量和成员方法，不重名，则super可以省略。</p>
<h2 id="方法的覆盖"><a href="#方法的覆盖" class="headerlink" title="方法的覆盖"></a>方法的覆盖</h2><p><strong>同名同参同返回</strong>  ：子类对父类参数相同、返回值相同、名字相同的方法重新进行定义，称为方法重写，也称为覆盖。</p>
<p>静态方法能被继承，但不能被覆盖，可使用“父类名.静态方法”的方法调用父类的同名方法。</p>
<p><strong>子类方法范围大于父类</strong>才可覆盖</p>
<p>注：同名同参不同返回：错误</p>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p><strong>同名不同参</strong></p>
<h2 id="依赖关系-Use-a"><a href="#依赖关系-Use-a" class="headerlink" title="依赖关系 Use-a"></a><strong>依赖关系 Use-a</strong></h2><p>一个类的对象是另一个类方法的参数或返回值</p>
<p>类图：虚线箭头</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>一个父类的某个方法被多个子类覆盖，产生各自的行为，称为多态。</p>
<h4 id="三个必备的条件"><a href="#三个必备的条件" class="headerlink" title="三个必备的条件"></a>三个必备的条件</h4><ol>
<li><strong>子类继承父类</strong></li>
<li><strong>子类方法覆盖父类的方法</strong></li>
<li><strong>父类引用指向子类对象</strong></li>
</ol>
<p><img src="/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680597849567.png" alt="1680597849567"></p>
<p><img src="/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680598351702.png" alt="1680598351702"></p>
<p>父类的引用指向子类的对象时，不能访问子类新增加的成员变量和成员方法，因此，要实现多态，子类必须覆盖父类的方法。</p>
<h4 id="声明类型和实际类型"><a href="#声明类型和实际类型" class="headerlink" title="声明类型和实际类型"></a>声明类型和实际类型</h4><ul>
<li>声明类型：声明变量时的类型。</li>
</ul>
<p> <strong>编译</strong>期间，依据声明的类型，判断引用可以调用的方法。</p>
<p>   所以，当父类引用指向子类对象时，只能调用父类中也定义的方法。</p>
<ul>
<li>实际类型：对象的实际类型，由创建对象的构造方法决定。</li>
</ul>
<p><strong>运行</strong>期间，判断所引用对象的实际类型。</p>
<ul>
<li>示例</li>
</ul>
<p> 变量o的声明类型是Object ，实际类型是GeometricObject1</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><ul>
<li>程序在执行期间，判断所引用对象的实际类型，根据其实际的类型调用其相应的方法</li>
</ul>
<p><img src="/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680760720484.png" alt="1680760720484"></p>
<p>多态的优点: 扩展性好</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h4 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h4><p>通过继承抽象类，可以实现多态，增强程序的可扩展性。</p>
<p>设计程序时，经常使用抽象类（abstract）， 抽象类只关心操作，不关心操作的具体实现细节。</p>
<p>程序的设计者：把主要精力放在程序设计上，不必关心程序细节的实现。</p>
<p>程序实现者：实现从抽象类继承而来的子类，要关注程序细节的实现。</p>
<h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><ul>
<li>抽象类：用关键字abstract修饰的类称为abstract类（抽象类）:</li>
</ul>
<p>类里0到多个抽象方法，有抽象方法必为抽象类，不能创建对象</p>
<p>abstract class A{</p>
<p>……}</p>
<ul>
<li><p>抽象方法：用关键字abstract修饰的方法称为abstract方法（抽象方法）。</p>
<p>注意：抽象方法只有定义，没有实现，即没有方法体。</p>
</li>
</ul>
<p>abstract int min(int x, int y);</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><strong>[修饰符（默认或public）] abstract class 类名{</strong></p>
<p>[修饰符（private、默认、protected或public）] [static] 类型 属性；</p>
<p>[修饰符（private、默认、protected或public) ] 构造方法名 （参数类型 参数1， [参数类型  参数2] … ）{</p>
<p>方法体</p>
<p>}</p>
<p>[修饰符（默认、protected或public）] [abstract] [static] 返回值类型 方法名 （参数类型 参数1，[参数类型 参数2] …）;</p>
<p>}</p>
<p>类图：斜体</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>抽象类不能用new运算符创建对象。</p>
<p> 继承抽象类的非抽象类子类对应抽象方法须覆盖</p>
<p>抽象类的构造方法通常使用protected修饰，因为只被子类使用。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>如果<strong>抽象类的所有的方法都是抽象的</strong>，则可以考虑使用接口。</p>
<p>接口是一种特殊的抽象类。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>在软件开发过程中，接口可以<strong>使设计与实现分离</strong>。在设计时只提供抽象接口，而不考虑具体实现。在实现阶段，再编写实现类实现接口。</li>
<li>Java采用单继承机制，不支持多继承性，即<strong>一个类最多只能有一个父类</strong>。为了克服单继承的缺点，java使用了接口，<strong>一个类可以实现多个接口</strong>。</li>
</ul>
<h4 id="声明格式"><a href="#声明格式" class="headerlink" title="声明格式"></a>声明格式</h4><p>[public] interface 接口名 [extends 父接口名]{</p>
<p>&#x2F;&#x2F;<strong>静态常量</strong>数据成员声明</p>
<p>[public] [static] [final] 属性类型 属性名 &#x3D; 常量值；</p>
<p>&#x2F;&#x2F;<strong>抽象方法</strong>声明</p>
<p>[public] [abstract] 返回值 方法名(参数列表)；</p>
<p>}</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>一个接口可以继承另一个接口。</p>
<p>接口的属性必须为静态常量，且权限必须是public，因此<strong>可以省略final和static修饰符</strong>。</p>
<p>接口的方法都是公共的抽象方法，所以<strong>允许省略public、abstract修饰符</strong>。</p>
<h4 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h4><p>类似继承，类和接口的关系，一个类可实现多个接口</p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>类可以<strong>实现implements</strong>一个或多个接口。</p>
<p>若实现多个接口，接口之间用逗号隔开。</p>
<p>实现接口的具体类必须重写接口的所有方法。</p>
<p>[修饰符（默认或public）] [abstract] class 类名 [extends 父类名] [implements 接口1，接口2 …]</p>
<p><img src="/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1681201330812.png" alt="1681201330812"></p>
<p>实现：虚线+箭头</p>
<p>A instanceof B 判断A是不是B的实例</p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><strong>instanceof</strong></h4><p>instanceof是运算符，判断一个对象是否为某个类的实例，如果是，返回true，否则返回false。</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a><strong>强制类型转换</strong></h4><p><strong>（只有有继承关系的可以）</strong></p>
<p>public interface Edible {</p>
<p>public abstract String howToEat();</p>
<p>}</p>
<p>…</p>
<p>Object[] objects &#x3D; {new Tiger(), new Chicken(), new Apple(),new Orange()};</p>
<p>System.out.println(((Edible)objects[i]).howToEat());</p>
<p>因为Object类无法加howToEat方法，可以将object类强制转化为Edible</p>
<p>“.”优先级高于 强制类型转换</p>
<h4 id="Comparable-接口"><a href="#Comparable-接口" class="headerlink" title="Comparable 接口"></a>Comparable 接口</h4><p>需求</p>
<p> 假设要比较同一个类的两个对象的大小，则该类需要实现Comparable接口。</p>
<p>定义</p>
<p><strong>泛型接口</strong></p>
<p>public interface Comparable <code>&lt;E&gt;</code> {</p>
<p>public int compareTo(E o);</p>
<p>}</p>
<p>在实现接口(容器类)时，泛型类型E被替换成一个具体的类型。</p>
<p>不加默认object</p>
<p>compareTo方法比较当前对象与给定对象o的原则：(默认)</p>
<p> 当前对象 &lt; o ，返回负整数；</p>
<p> 当前对象 &#x3D; o ，返回0；</p>
<p> 当前对象 &gt; o ，返回正整数；</p>
<p>对象数组排序</p>
<p>java.util.Arrays.sort</p>
<p>java.lang.Object.equals</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj)</span><br></pre></td></tr></table></figure>

<p>指示一些其他对象是否等于此。<code>equals</code>方法在非空对象引用上实现等价关系：</p>
<ul>
<li><em>自反性</em> ：对于任何非空的参考值 <code>x</code> ， <code>x.equals(x)</code>应该返回 <code>true</code> 。</li>
<li>它是<em>对称的</em> ：对于任何非空引用值 <code>x</code>和 <code>y</code> ， <code>x.equals(y)</code>应该返回 <code>true</code>当且仅当 <code>y.equals(x)</code>回报 <code>true</code> 。</li>
<li><em>传递性</em> ：对于任何非空引用值 <code>x</code> ， <code>y</code>和 <code>z</code> ，如果 <code>x.equals(y)</code>回报 <code>true</code>个 <code>y.equals(z)</code>回报 <code>true</code> ，然后 <code>x.equals(z)</code>应该返回 <code>true</code> 。</li>
<li>它是<em>一致的</em> ：对于任何非空引用值 <code>x</code>和 <code>y</code> ，多次调用 <code>x.equals(y)</code>始终返回 <code>true</code>或始终返回 <code>false</code> ，没有设置中使用的信息 <code>equals</code>比较上的对象被修改。</li>
<li>对于任何非空的参考值 <code>x</code> ， <code>x.equals(null)</code>应该返回 <code>false</code> 。</li>
</ul>
<p>该 <code>equals</code>类方法 <code>Object</code>实现对象上差别可能性最大的相等关系; 也就是说，对于任何非空的参考值 <code>x</code>和 <code>y</code> ，当且仅当 <code>x</code>和 <code>y</code>引用相同的对象（ <code>x == y</code>具有值 <code>true</code> ）时，该方法返回 <code>true</code> 。</p>
<p>请注意，无论何时覆盖该方法，通常需要覆盖 <code>hashCode</code>方法，以便维护 <code>hashCode</code>方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。</p>
<p>参数 <code>obj</code> - 与之比较的参考对象。<strong>结果</strong> <code>true</code>如果此对象与obj参数相同; <code>false</code>否则。</p>
<p>泛型</p>
<p>ArrayList <code>&lt;E&gt;</code></p>
<p>加泛型后不需强制类型转换</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/28/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/" data-id="clrx9mt3b0008j4tlc7b87a5n" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/04/18/%E5%BC%82%E5%B8%B8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2023/03/14/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E5%99%A8/">计算机视觉与深度学习-线性分类器</a>
          </li>
        
          <li>
            <a href="/2024/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E4%BB%8B%E7%BB%8D/">计算机视觉与深度学习-图像分类任务介绍</a>
          </li>
        
          <li>
            <a href="/2024/01/28/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86/">我回来了</a>
          </li>
        
          <li>
            <a href="/2023/09/04/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 missbyebye<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>