<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="missbyebye">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-我回来了" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/28/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86/" class="article-date">
  <time class="dt-published" datetime="2024-01-28T08:53:41.000Z" itemprop="datePublished">2024-01-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/28/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86/">我回来了</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>大二暑假，我回来了orz</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/28/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86/" data-id="clrx9mt330004j4tlerhofea1" data-title="我回来了" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java程序设计实践" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/04/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/" class="article-date">
  <time class="dt-published" datetime="2023-09-04T00:53:50.040Z" itemprop="datePublished">2023-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="界面开发"><a href="#界面开发" class="headerlink" title="界面开发"></a>界面开发</h1><h3 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h3><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>重量级组件：AWT 适合开发简单图形界面 位于java.awt</p>
<p>轻量级组件：Swing 可开发复杂图形界面</p>
<p>java FX 取代swing</p>
<h4 id="Java-FX基本结构"><a href="#Java-FX基本结构" class="headerlink" title="Java FX基本结构"></a>Java FX基本结构</h4><p>继承application类</p>
<p>重写stage方法</p>
<p>stage舞台 scene场景 nodes演员</p>
<h4 id="面板-UI组件"><a href="#面板-UI组件" class="headerlink" title="面板 UI组件"></a>面板 UI组件</h4><p>坐标系</p>
<h4 id="节点的通用属性和方法"><a href="#节点的通用属性和方法" class="headerlink" title="节点的通用属性和方法"></a>节点的通用属性和方法</h4><p>HTML CSS样式</p>
<p>HTML标签外观样式只有黑白</p>
<p>设置style的方法</p>
<ul>
<li>调用节点的setStyle方法</li>
<li>编写单独的CSS文件</li>
</ul>
<h4 id="面板类型"><a href="#面板类型" class="headerlink" title="面板类型"></a>面板类型</h4><p>Pane 所有面板基类</p>
<p>StackPane 居中</p>
<p>FlowPane </p>
<ul>
<li>可设置左&gt;右 或 上&gt;下放置顺序，自动换行</li>
<li>对齐方式Pos Hpos Vpos</li>
<li>节点间隙 hgap(水平距离) vgap(垂直)</li>
<li>Insets类设置面板边框</li>
</ul>
<p>GridPane 节点布局在网格布局中，先列后行</p>
<p>BorderPane 分为5个区域，可以装节点或者面板</p>
<p>HBox水平</p>
<p>VBox垂直放置</p>
<h3 id="事件驱动机制"><a href="#事件驱动机制" class="headerlink" title="事件驱动机制"></a>事件驱动机制</h3><p>事件源对象 一个事件 事件处理器</p>
<ul>
<li><p>源对象 按钮 文本。。。</p>
</li>
<li><p>事件对象</p>
</li>
</ul>
<p>Event类：</p>
<p>动作事件actionevent</p>
<p>窗口事件</p>
<p>输入事件Inputevent</p>
<ul>
<li>事件处理器<br>内部类<br>匿名类 不取类名，new后接代码，只用一次<br>lambda表达式<br>例：bottom1.setOnAction(e -&gt;{    handle方法内的代码  });</li>
</ul>
<h4 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a>事件处理机制</h4><p>注册处理器和处理事件</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/04/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/" data-id="clrx9mt2v0000j4tlbhgifikh" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数学建模论文" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/" class="article-date">
  <time class="dt-published" datetime="2023-04-27T12:32:38.765Z" itemprop="datePublished">2023-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><strong>标题</strong></p>
<p><strong>摘要</strong></p>
<p><strong>关键词</strong> 3-5</p>
<p>&#x2F;&#x2F;以上大约一页（不超） 不要出现参赛队员信息</p>
<p><strong>正文</strong></p>
<ol>
<li>问题重述</li>
<li>问题分析</li>
<li>模型假设</li>
<li>符号说明</li>
<li>模型建立与求解</li>
<li>模型评价</li>
</ol>
<p><strong>参考文献（&lt;10）</strong></p>
<p><strong>附录</strong></p>
<p>代码 搜录的数据（支撑材料）</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>题目本身标题 &#x2F;结合解题模型的标题</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>高度压缩，全面概述</p>
<ol>
<li>总结问题背景，要解决的主要问题，采用的模型</li>
</ol>
<p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682599715971.png" alt="1682599715971"></p>
<ol start="2">
<li>对研究的每一个问题都阐述   xx方法，xx模型，如何求解，结果，解决问题，特色创新点<br>对于问题一：……</li>
<li>除了解决基本问题，还有什么有意义的工作（锦上添花？）</li>
</ol>
<p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682599955522.png" alt="1682599955522"></p>
<h2 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h2><ol>
<li>解读后重新表述，不照抄</li>
<li>赛题中可能模糊的概念澄清说明</li>
<li>明确要解决的问题</li>
</ol>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682600293229.png" alt="1682600293229"></p>
<h2 id="模型的假设"><a href="#模型的假设" class="headerlink" title="模型的假设"></a>模型的假设</h2><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682600329846.png" alt="1682600329846"></p>
<p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682600388013.png" alt="1682600388013"></p>
<p>符号说明</p>
<p>图表</p>
<p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682600504052.png" alt="1682600504052"></p>
<h2 id="模型的建立与求解"><a href="#模型的建立与求解" class="headerlink" title="模型的建立与求解"></a>模型的建立与求解</h2><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682600605955.png" alt="1682600605955"></p>
<p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682600708734.png" alt="1682600708734"></p>
<p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682600894182.png" alt="1682600894182"></p>
<p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682600939488.png" alt="1682600939488"></p>
<p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682601133005.png" alt="1682601133005"></p>
<p>尽量定量表述</p>
<h2 id="模型的检验与灵敏度分析"><a href="#模型的检验与灵敏度分析" class="headerlink" title="模型的检验与灵敏度分析"></a>模型的检验与灵敏度分析</h2><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682601257457.png" alt="1682601257457"></p>
<h2 id="模型的评价与改进"><a href="#模型的评价与改进" class="headerlink" title="模型的评价与改进"></a>模型的评价与改进</h2><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682601466098.png" alt="1682601466098"></p>
<p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/1682601622810.png" alt="1682601622810"></p>
<p>PDF文件，支撑材料（可有可不有）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/" data-id="clrx9mt350005j4tl262g0adg" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数学建模-类型大纲" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/26/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E7%B1%BB%E5%9E%8B%E5%A4%A7%E7%BA%B2/" class="article-date">
  <time class="dt-published" datetime="2023-04-26T13:30:11.198Z" itemprop="datePublished">2023-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>不全，有的是模型，有的是方法，分类仅供参考,qwq写不完了，发发</p>
<h2 id="预测类"><a href="#预测类" class="headerlink" title="预测类"></a>预测类</h2><h4 id="灰色关联分析与预测模型-x2F-x2F-微分方程"><a href="#灰色关联分析与预测模型-x2F-x2F-微分方程" class="headerlink" title="灰色关联分析与预测模型&#x2F;&#x2F;微分方程"></a>灰色关联分析与预测模型&#x2F;&#x2F;微分方程</h4><p>适用：直接性关联分析 小样本预测</p>
<ul>
<li>灰色系统 白色系统 黑色系统<br>白色系统 系统内部信息完全已知<br>灰色系统 部分已知部分未知，系统内各元素没有确定关系<br>黑箱系统 内部未知，只能通过与外界联系来观测研究</li>
<li>灰色预测法 对含有不确定因素的系统进行预测<br>鉴别系统内元素发展趋势相异程度，进行关联分析，寻找规律，建立<strong>微分方程</strong>模型，预测未来发展</li>
</ul>
<h4 id="插值与拟合"><a href="#插值与拟合" class="headerlink" title="插值与拟合"></a>插值与拟合</h4><p>插值–主要用于求函数值</p>
<p>拟合–求目标函数，进行预测等进一步分析</p>
<h4 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h4><h4 id="时间序列分析"><a href="#时间序列分析" class="headerlink" title="时间序列分析"></a>时间序列分析</h4><h2 id="评价类"><a href="#评价类" class="headerlink" title="评价类"></a>评价类</h2><ol>
<li>主观赋权法 综合咨询评分确定权重<br>综合指数法 模糊综合评判法 层次分析法 功效系数法…</li>
<li>客观赋权法 根据各指标间相关关系或个指标变异程度确定权重<br>主成分分析法 因子分析法 理想解法（TOPSIS）…</li>
</ol>
<h4 id="层次分析法（AHP）-x2F-x2F-线代"><a href="#层次分析法（AHP）-x2F-x2F-线代" class="headerlink" title="层次分析法（AHP）&#x2F;&#x2F;线代"></a>层次分析法（AHP）&#x2F;&#x2F;线代</h4><ul>
<li>解决多目标的复杂问题，定性分析与定量分析结合</li>
</ul>
<p>定性–衡量相对重要程度</p>
<p>定量–根据重要程度分配每个元素权重</p>
<ul>
<li>应用：1 应用于决策问题，选最佳方案<br>2 评价类问题<br>3 指标体系优选</li>
</ul>
<h4 id="TOPSIS法（理想解法）"><a href="#TOPSIS法（理想解法）" class="headerlink" title="TOPSIS法（理想解法）"></a>TOPSIS法（理想解法）</h4><p>多指标评价方法。这种方法通过构造评价问题的正理想解和负理想解，即各指标的最优解和最劣解，通过计算每个方案到理想方案的相对贴近度，即靠近正理想解和远离负理想解的程度，来对方案进行排序，从而选出最优方案。</p>
<h4 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h4><p>通过少数几个主成分解释多个变量间内部结构，将相关性很高的变量转化为互相独立或者不相关的变量</p>
<h4 id="因子分析"><a href="#因子分析" class="headerlink" title="因子分析"></a>因子分析</h4><p>斯皮尔曼，主成分分析推广扩展</p>
<h4 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h4><p>分类</p>
<h4 id="模糊综合评价"><a href="#模糊综合评价" class="headerlink" title="模糊综合评价"></a>模糊综合评价</h4><p>从精确到模糊</p>
<h2 id="机理分析类"><a href="#机理分析类" class="headerlink" title="机理分析类"></a>机理分析类</h2><h2 id="优化类"><a href="#优化类" class="headerlink" title="优化类"></a>优化类</h2><h4 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h4><ul>
<li>目标函数</li>
</ul>
<p>求最大或最小值</p>
<ul>
<li>决策变量</li>
</ul>
<p>可变的，自变量</p>
<ul>
<li>约束变量</li>
</ul>
<p>不变的，限制条件</p>
<p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E7%B1%BB%E5%9E%8B%E5%A4%A7%E7%BA%B2/1682516391875.png" alt="1682516391875"></p>
<h4 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h4><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><h4 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h4><h4 id="多目标规划"><a href="#多目标规划" class="headerlink" title="多目标规划"></a>多目标规划</h4><p>&#x2F;&#x2F;不知道怎么分了qwq</p>
<h4 id="相关性分析"><a href="#相关性分析" class="headerlink" title="相关性分析"></a>相关性分析</h4><h4 id="典型相关分析"><a href="#典型相关分析" class="headerlink" title="典型相关分析"></a>典型相关分析</h4><p>多对多，两组随机变量之间关系</p>
<h4 id="方差分析"><a href="#方差分析" class="headerlink" title="方差分析"></a>方差分析</h4><p>找出有显著影响的因素</p>
<p>……</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/26/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E7%B1%BB%E5%9E%8B%E5%A4%A7%E7%BA%B2/" data-id="clrx9mt320003j4tl38b598uy" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-异常" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/18/%E5%BC%82%E5%B8%B8/" class="article-date">
  <time class="dt-published" datetime="2023-04-18T08:33:17.267Z" itemprop="datePublished">2023-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="异常的含义"><a href="#异常的含义" class="headerlink" title="异常的含义"></a>异常的含义</h2><p>对于一个程序来说，可能会发生三种错误：语法错误、运行时错误和逻辑错误。</p>
<p> <strong>语法错误</strong>在使用javac命令编译期间，就可以给用户相应的提示。</p>
<p> <strong>运行时错误</strong>(异常)是程序在运行中出现意料不到的情况，如除数为零、数组下标越界、需要的文件不存在或打不开、传入参数为空或不符合指定范围等。</p>
<p> <strong>逻辑错误</strong>是程序的运行结果和预想的结果不一致，这是一种难以调试的错误。</p>
<p>使用Java的异常处理机制主要是处理运行时的错误，异常就是运行时的错误（系统抛出的）。</p>
<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>异常类的层次</p>
<ul>
<li>异常类的层次：Throwable类是Error类（错误类）和Exception类（异常类）的父类，同时Throwable也是Object的直接子类。</li>
<li>Error类：指的是系统或运行环境出现的错误，即使捕捉到也无法处理，由Java虚拟机生成并抛出，包括系统崩溃、动态链接失败、虚拟机错误等，在Java程序中不做处理。</li>
<li>Exception类：许多子类。</li>
</ul>
<p><img src="/image/%E5%BC%82%E5%B8%B8/1681807560569.png" alt="1681807560569"></p>
<p>Exception类</p>
<p> Exception类:指一些可以被捕获且可能恢复的异常情况，是一般程序中可预知的</p>
<p> 分为两大类：<strong>运行时（Runtime）异常（<strong><strong>可处理可不处理</strong></strong>）</strong>和<strong>检测（Checked）异常</strong>（必须管）</p>
<p>Exception类——运行时异常</p>
<p>RuntimeException（运行时异常）：包括所有RuntimeException类及其子类的实例，如</p>
<ul>
<li>除数为0异常：ArithmeticException</li>
<li>数组访问越界：ArrayIndexOutOfBoundsException</li>
<li>访问空指针： NullPointerException</li>
<li><img src="/image/%E5%BC%82%E5%B8%B8/1685430482170.png" alt="1685430482170"></li>
</ul>
<p>不需要捕获运行时异常</p>
<p>Exception类——检测异常（必须处理）</p>
<p>检测异常：不是RuntimeException类及其子类的异常。如</p>
<ul>
<li>I&#x2F;O错误：IOException（输入输出异常）</li>
<li>找不到要打开的文件：FileNotFoundException</li>
<li>试图在文件末尾读取数据： EOFException</li>
</ul>
<p>检测异常的处理方式</p>
<ol>
<li>在Java程序的执行过程中，如果出现了异常事件，就会生成一个异常对象（包括运行时异常和检测异常）。生成的异常对象将<strong>传递给Java运行时系统</strong>，这一异常的产生和提交过程称为抛出（throw）异常。</li>
<li>当Java运行时系统得到一个异常对象时，它将会寻找处理这一异常的代码(方法)。找到能够处理这种类型的异常的方法后，运行时系统把当前异常对象<strong>交给这个方法进行处理</strong>，这一过程称为捕获（catch）异常。</li>
</ol>
<p>try语句块含有可能出现异常的程序代码，可能会抛出一个或多个异常，因此try后面可跟一个或多个catch。</p>
<ul>
<li>当try中语句块没有发生异常时，不执行后面的catch语句块。</li>
<li>多catch情况下，异常类遵循由<strong>子类到父类</strong>，由<strong>具体到抽象</strong>的顺序，或为<strong>并列</strong>关系。</li>
</ul>
<p><img src="/image/%E5%BC%82%E5%B8%B8/1681970455136.png" alt="1681970455136"></p>
<p><strong>finally</strong></p>
<p>不管try块中的代码是否出现异常，也不管哪一个catch块被执行，finally块总会被执行。</p>
<p>finally块主要用于<strong>释放资源</strong>。在try块中打开了一些物理资源（如数据库连接、网络连接和磁盘文件），在finally块中要显式释放。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/18/%E5%BC%82%E5%B8%B8/" data-id="clrx9mt2z0001j4tl4r4tbowb" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-继承和接口" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/28/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time class="dt-published" datetime="2023-03-28T07:36:38.545Z" itemprop="datePublished">2023-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="子类和父类"><a href="#子类和父类" class="headerlink" title="子类和父类"></a>子类和父类</h2><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在一般类（父类）的基础上添加新的成员属性和成员方法，产生新的类（子类)</p>
<p>继承是面向对象的第二大特征，是软件重用方面的重要功能。</p>
<p>类图表示 子类指向父类</p>
<h5 id="关系-is-a"><a href="#关系-is-a" class="headerlink" title="关系 is a"></a>关系 is a</h5><p>父类和子类之间是“<strong>is-a</strong>”的关系，即子类是父类的一个特例。</p>
<p>父类：抽取一类事物的共同属性和方法。</p>
<p>子类：添加特殊事物的特殊属性和方法。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>[修饰符（默认或public）]  class  子类名  extends  父类名</p>
<h4 id="子类的继承性"><a href="#子类的继承性" class="headerlink" title="子类的继承性"></a>子类的继承性</h4><p>由父类的属性和方法前面的<strong>访问控制修饰符</strong>，以及子类和父类<strong>是否同包</strong>来决定子类能否继承父类的属性和方法。</p>
<ul>
<li>默认成员变量和成员方法的继承性</li>
</ul>
<p>默认的成员变量和成员方法可以被<strong>同包</strong>中的其他类访问</p>
<ul>
<li>被protected修饰的成员变量和成员方法的继承性</li>
</ul>
<p>被proteced修饰的成员变量和成员方法可以被<strong>同包中的其他类</strong>（当然包括同包中的子类）访问，也可以被<strong>不同包中的子类</strong>访问。也即，子类不管与父类是否同包，都可以继承父类中被protected修饰的成员变量和成员方法</p>
<p><em>布尔型 读取方法不是 get而是is</em></p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object类是所有类的祖先，即使定义没有写extends Object，也等效于写了。</p>
<p>String toString()：返回该对象的字符串表示。包名.类名+@+地址</p>
<p>输出对象的toString()，可直接输出对象名</p>
<p>所有子类覆盖此方法。</p>
<p>Object的toString()方法通常不能满足要求，子类需要覆盖该方法，返回一个描述子类对象的字符串。</p>
<p>Object clone()：将当前对象克隆。</p>
<p>public boolean equals(Object c);  (对象调用跟c比)</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>在生成子类对象的时候，会包含一个父类对象，<strong>super表示父类对象的引用。</strong></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li>调用父类的构造方法</li>
</ol>
<p>super（）</p>
<p>super(参数列表)</p>
<p>注意：调用父类构造方法的语句，必须放在第一句</p>
<ol start="2">
<li>调用父类的成员属性或成员方法</li>
</ol>
<p>super.成员属性</p>
<p>super.成员方法(参数列表)</p>
<h4 id="构造方法链"><a href="#构造方法链" class="headerlink" title="构造方法链"></a>构造方法链</h4><p>一个子类的对象内部包含父类的对象。</p>
<p>问题：如果子类的构造方法中没有显式的调用父类的构造方法，则嵌在子类内部的父类对象如何构建？</p>
<p>如果子类构造方法没有显式的调用父类的构造方法，则编译器自动添加super()语句，调用父类的构造方法，创建父类对象。</p>
<p>当一个父类中有有参的构造方法时，一定显式添加一个无参的构造方法。<em>避免子类构造方法因没有对应构造方法报错</em></p>
<p>如果一个子类的父类还有父类，……，当构造一个子类的对象时，会从最高级的父类开始，依次调用各个类的构造方法，直到最后一个构造方法被调用，形成构造方法链。</p>
<p>例子：下面是三个类的继承关系，在创建Faculty对象的时候，会先调用Person的构造方法，创建Person对象，再调用Employee的构造方法，创建Employee对象，最后调用Faculty的构造方法，创建Faculty对象。</p>
<p><img src="/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680158157703.png" alt="1680158157703"></p>
<h4 id="调用父类的方法"><a href="#调用父类的方法" class="headerlink" title="调用父类的方法"></a>调用父类的方法</h4><p>如果子类添加的成员变量和成员方法，与从父类继承而来的成员变量和成员方法，不重名，则super可以省略。</p>
<h2 id="方法的覆盖"><a href="#方法的覆盖" class="headerlink" title="方法的覆盖"></a>方法的覆盖</h2><p><strong>同名同参同返回</strong>  ：子类对父类参数相同、返回值相同、名字相同的方法重新进行定义，称为方法重写，也称为覆盖。</p>
<p>静态方法能被继承，但不能被覆盖，可使用“父类名.静态方法”的方法调用父类的同名方法。</p>
<p><strong>子类方法范围大于父类</strong>才可覆盖</p>
<p>注：同名同参不同返回：错误</p>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p><strong>同名不同参</strong></p>
<h2 id="依赖关系-Use-a"><a href="#依赖关系-Use-a" class="headerlink" title="依赖关系 Use-a"></a><strong>依赖关系 Use-a</strong></h2><p>一个类的对象是另一个类方法的参数或返回值</p>
<p>类图：虚线箭头</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>一个父类的某个方法被多个子类覆盖，产生各自的行为，称为多态。</p>
<h4 id="三个必备的条件"><a href="#三个必备的条件" class="headerlink" title="三个必备的条件"></a>三个必备的条件</h4><ol>
<li><strong>子类继承父类</strong></li>
<li><strong>子类方法覆盖父类的方法</strong></li>
<li><strong>父类引用指向子类对象</strong></li>
</ol>
<p><img src="/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680597849567.png" alt="1680597849567"></p>
<p><img src="/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680598351702.png" alt="1680598351702"></p>
<p>父类的引用指向子类的对象时，不能访问子类新增加的成员变量和成员方法，因此，要实现多态，子类必须覆盖父类的方法。</p>
<h4 id="声明类型和实际类型"><a href="#声明类型和实际类型" class="headerlink" title="声明类型和实际类型"></a>声明类型和实际类型</h4><ul>
<li>声明类型：声明变量时的类型。</li>
</ul>
<p> <strong>编译</strong>期间，依据声明的类型，判断引用可以调用的方法。</p>
<p>   所以，当父类引用指向子类对象时，只能调用父类中也定义的方法。</p>
<ul>
<li>实际类型：对象的实际类型，由创建对象的构造方法决定。</li>
</ul>
<p><strong>运行</strong>期间，判断所引用对象的实际类型。</p>
<ul>
<li>示例</li>
</ul>
<p> 变量o的声明类型是Object ，实际类型是GeometricObject1</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><ul>
<li>程序在执行期间，判断所引用对象的实际类型，根据其实际的类型调用其相应的方法</li>
</ul>
<p><img src="/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1680760720484.png" alt="1680760720484"></p>
<p>多态的优点: 扩展性好</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h4 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h4><p>通过继承抽象类，可以实现多态，增强程序的可扩展性。</p>
<p>设计程序时，经常使用抽象类（abstract）， 抽象类只关心操作，不关心操作的具体实现细节。</p>
<p>程序的设计者：把主要精力放在程序设计上，不必关心程序细节的实现。</p>
<p>程序实现者：实现从抽象类继承而来的子类，要关注程序细节的实现。</p>
<h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><ul>
<li>抽象类：用关键字abstract修饰的类称为abstract类（抽象类）:</li>
</ul>
<p>类里0到多个抽象方法，有抽象方法必为抽象类，不能创建对象</p>
<p>abstract class A{</p>
<p>……}</p>
<ul>
<li><p>抽象方法：用关键字abstract修饰的方法称为abstract方法（抽象方法）。</p>
<p>注意：抽象方法只有定义，没有实现，即没有方法体。</p>
</li>
</ul>
<p>abstract int min(int x, int y);</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><strong>[修饰符（默认或public）] abstract class 类名{</strong></p>
<p>[修饰符（private、默认、protected或public）] [static] 类型 属性；</p>
<p>[修饰符（private、默认、protected或public) ] 构造方法名 （参数类型 参数1， [参数类型  参数2] … ）{</p>
<p>方法体</p>
<p>}</p>
<p>[修饰符（默认、protected或public）] [abstract] [static] 返回值类型 方法名 （参数类型 参数1，[参数类型 参数2] …）;</p>
<p>}</p>
<p>类图：斜体</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>抽象类不能用new运算符创建对象。</p>
<p> 继承抽象类的非抽象类子类对应抽象方法须覆盖</p>
<p>抽象类的构造方法通常使用protected修饰，因为只被子类使用。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>如果<strong>抽象类的所有的方法都是抽象的</strong>，则可以考虑使用接口。</p>
<p>接口是一种特殊的抽象类。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>在软件开发过程中，接口可以<strong>使设计与实现分离</strong>。在设计时只提供抽象接口，而不考虑具体实现。在实现阶段，再编写实现类实现接口。</li>
<li>Java采用单继承机制，不支持多继承性，即<strong>一个类最多只能有一个父类</strong>。为了克服单继承的缺点，java使用了接口，<strong>一个类可以实现多个接口</strong>。</li>
</ul>
<h4 id="声明格式"><a href="#声明格式" class="headerlink" title="声明格式"></a>声明格式</h4><p>[public] interface 接口名 [extends 父接口名]{</p>
<p>&#x2F;&#x2F;<strong>静态常量</strong>数据成员声明</p>
<p>[public] [static] [final] 属性类型 属性名 &#x3D; 常量值；</p>
<p>&#x2F;&#x2F;<strong>抽象方法</strong>声明</p>
<p>[public] [abstract] 返回值 方法名(参数列表)；</p>
<p>}</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>一个接口可以继承另一个接口。</p>
<p>接口的属性必须为静态常量，且权限必须是public，因此<strong>可以省略final和static修饰符</strong>。</p>
<p>接口的方法都是公共的抽象方法，所以<strong>允许省略public、abstract修饰符</strong>。</p>
<h4 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h4><p>类似继承，类和接口的关系，一个类可实现多个接口</p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>类可以<strong>实现implements</strong>一个或多个接口。</p>
<p>若实现多个接口，接口之间用逗号隔开。</p>
<p>实现接口的具体类必须重写接口的所有方法。</p>
<p>[修饰符（默认或public）] [abstract] class 类名 [extends 父类名] [implements 接口1，接口2 …]</p>
<p><img src="/image/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/1681201330812.png" alt="1681201330812"></p>
<p>实现：虚线+箭头</p>
<p>A instanceof B 判断A是不是B的实例</p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><strong>instanceof</strong></h4><p>instanceof是运算符，判断一个对象是否为某个类的实例，如果是，返回true，否则返回false。</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a><strong>强制类型转换</strong></h4><p><strong>（只有有继承关系的可以）</strong></p>
<p>public interface Edible {</p>
<p>public abstract String howToEat();</p>
<p>}</p>
<p>…</p>
<p>Object[] objects &#x3D; {new Tiger(), new Chicken(), new Apple(),new Orange()};</p>
<p>System.out.println(((Edible)objects[i]).howToEat());</p>
<p>因为Object类无法加howToEat方法，可以将object类强制转化为Edible</p>
<p>“.”优先级高于 强制类型转换</p>
<h4 id="Comparable-接口"><a href="#Comparable-接口" class="headerlink" title="Comparable 接口"></a>Comparable 接口</h4><p>需求</p>
<p> 假设要比较同一个类的两个对象的大小，则该类需要实现Comparable接口。</p>
<p>定义</p>
<p><strong>泛型接口</strong></p>
<p>public interface Comparable <code>&lt;E&gt;</code> {</p>
<p>public int compareTo(E o);</p>
<p>}</p>
<p>在实现接口(容器类)时，泛型类型E被替换成一个具体的类型。</p>
<p>不加默认object</p>
<p>compareTo方法比较当前对象与给定对象o的原则：(默认)</p>
<p> 当前对象 &lt; o ，返回负整数；</p>
<p> 当前对象 &#x3D; o ，返回0；</p>
<p> 当前对象 &gt; o ，返回正整数；</p>
<p>对象数组排序</p>
<p>java.util.Arrays.sort</p>
<p>java.lang.Object.equals</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj)</span><br></pre></td></tr></table></figure>

<p>指示一些其他对象是否等于此。<code>equals</code>方法在非空对象引用上实现等价关系：</p>
<ul>
<li><em>自反性</em> ：对于任何非空的参考值 <code>x</code> ， <code>x.equals(x)</code>应该返回 <code>true</code> 。</li>
<li>它是<em>对称的</em> ：对于任何非空引用值 <code>x</code>和 <code>y</code> ， <code>x.equals(y)</code>应该返回 <code>true</code>当且仅当 <code>y.equals(x)</code>回报 <code>true</code> 。</li>
<li><em>传递性</em> ：对于任何非空引用值 <code>x</code> ， <code>y</code>和 <code>z</code> ，如果 <code>x.equals(y)</code>回报 <code>true</code>个 <code>y.equals(z)</code>回报 <code>true</code> ，然后 <code>x.equals(z)</code>应该返回 <code>true</code> 。</li>
<li>它是<em>一致的</em> ：对于任何非空引用值 <code>x</code>和 <code>y</code> ，多次调用 <code>x.equals(y)</code>始终返回 <code>true</code>或始终返回 <code>false</code> ，没有设置中使用的信息 <code>equals</code>比较上的对象被修改。</li>
<li>对于任何非空的参考值 <code>x</code> ， <code>x.equals(null)</code>应该返回 <code>false</code> 。</li>
</ul>
<p>该 <code>equals</code>类方法 <code>Object</code>实现对象上差别可能性最大的相等关系; 也就是说，对于任何非空的参考值 <code>x</code>和 <code>y</code> ，当且仅当 <code>x</code>和 <code>y</code>引用相同的对象（ <code>x == y</code>具有值 <code>true</code> ）时，该方法返回 <code>true</code> 。</p>
<p>请注意，无论何时覆盖该方法，通常需要覆盖 <code>hashCode</code>方法，以便维护 <code>hashCode</code>方法的通用合同，该方法规定相等的对象必须具有相等的哈希码。</p>
<p>参数 <code>obj</code> - 与之比较的参考对象。<strong>结果</strong> <code>true</code>如果此对象与obj参数相同; <code>false</code>否则。</p>
<p>泛型</p>
<p>ArrayList <code>&lt;E&gt;</code></p>
<p>加泛型后不需强制类型转换</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/28/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3/" data-id="clrx9mt3b0008j4tlc7b87a5n" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-类和对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/14/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="dt-published" datetime="2023-03-14T07:21:25.126Z" itemprop="datePublished">2023-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h4 id="类描述对象的下述信息："><a href="#类描述对象的下述信息：" class="headerlink" title="类描述对象的下述信息："></a>类描述对象的下述信息：</h4><ul>
<li>数据域（或称为属性、成员变量）：描述对象的状态，是静态信息。</li>
<li>方法（成员方法）：描述动态信息，说明每个对象的行为特征。#### UML</li>
</ul>
<p><img src="/image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1678779194470.png" alt="1678779194470"></p>
<p><img src="/image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1678779390789.png" alt="1678779390789"></p>
<h3 id="创建和使用对象的步骤"><a href="#创建和使用对象的步骤" class="headerlink" title="创建和使用对象的步骤"></a>创建和使用对象的步骤</h3><ol>
<li>声明对象</li>
</ol>
<p>Circle circle1;</p>
<ol start="2">
<li>使用new调用构造方法创建对象</li>
</ol>
<p>circle1 &#x3D; new Circle()</p>
<p>Circle2 &#x3D; new Circle(25);</p>
<ol start="3">
<li>使用对象：使用对象的成员变量和方法</li>
</ol>
<p>System.out.pritnln(circle1.radius);</p>
<p>System.out.pritnln(circle1.getArea());</p>
<h4 id="将两个类放到一个文件中"><a href="#将两个类放到一个文件中" class="headerlink" title="将两个类放到一个文件中"></a>将两个类放到一个文件中</h4><p>注意事项</p>
<ul>
<li>Java应用程序源文件是由若干个类（class）组成。</li>
<li>但是，一个源文件中最多只能有一个public类。其他类的个数不限。</li>
<li>如果源文件包含一个public类，它必需按该类名命名。</li>
<li>如果源文件不包含public类，则文件名与其中任意一个类名相同即可。</li>
<li>如果源文件有多个类，则编译源文件后，生成多个.class文件，每个class文件只存放一个类的字节码文件，且与类名相同。</li>
<li>一个应用程序必须有且只有一个类包含main方法，是整个应用程序的入口。</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法的特点：</p>
<p>名称与类名一样</p>
<p>无返回值类型</p>
<p>用来创建对象</p>
<p>一个类可有零个或多个构造方法</p>
<p>零个：创建对象时系统会自动生成一个空的构造方法。</p>
<p>多个：如果定义了有参构造方法，又要使用无参构造方法，需要在类体中显式定义无参构造方法。</p>
<h2 id="静态变量、静态常量和静态方法"><a href="#静态变量、静态常量和静态方法" class="headerlink" title="静态变量、静态常量和静态方法"></a>静态变量、静态常量和静态方法</h2><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p><img src="https://file+.vscode-resource.vscode-cdn.net/c%3A/blog/source/_posts/image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1678945604554.png" alt="1678945604554"></p>
<h4 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h4><ul>
<li>定义方法</li>
</ul>
<p>final static 数据类型 常量名 ＝ 值；</p>
<p>final static double PI &#x3D; 3.14;</p>
<ul>
<li>特点</li>
</ul>
<p>类中的常量被所有的对象所共享。</p>
<p>其值<strong>一旦确定，不可改变</strong>。全大写</p>
<h4 id="静态方法（类方法）"><a href="#静态方法（类方法）" class="headerlink" title="静态方法（类方法）"></a>静态方法（类方法）</h4><p>成员方法分为实例方法和类方法（静态方法）</p>
<p>实例方法：不被static修饰</p>
<p>只能创建对象后，通过对象调用，如Scanner类的使用。</p>
<p>类方法：被static修饰</p>
<p>通过类名调用,也可以通过对象调用</p>
<p>Math.sqrt(12.0);</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>实例变量和实例方法与某个具体的实例相关，只能创建了实例后，通过实例调用。</li>
<li>类变量和类方法不与某个实例相关，不需要创建实例，直接通过类名调用。</li>
</ul>
<p>因此，在类方法中可以调用其他类方法，但不可以调用实例方法；而在实例方法中，既可以调用类方法，也可以调用实例方法。</p>
<p>(<strong>static方法不能出现不用static修饰的方法变量</strong>….)</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>学习Java语言时，使用已经存在的类，避免一切从头做起，这是面向对象编程的一个重要理念：软件复用。</p>
<p>众多的类，不可避免会产生类名的冲突，如何将不同的类区分开？Java引入包（package）机制，提供类的多重命名空间。</p>
<p>包名：域名倒写</p>
<h4 id="在另一个类中使用有包的类"><a href="#在另一个类中使用有包的类" class="headerlink" title="在另一个类中使用有包的类"></a>在另一个类中使用有包的类</h4><p>两种方法</p>
<p>方法一：写全类名。</p>
<p>书写比较麻烦，不建议使用</p>
<p>方法二：使用import语句导入类的定义。</p>
<p>建议使用</p>
<p>java类库</p>
<p>Java类库就是一些已写好、可供调用的类的集合。</p>
<p>Java将这些类整理在不同的包中。</p>
<p>每一包里都包含一些特定功能的类和接口，用import引入这些类，就可以在程序中使用了。</p>
<p>包名以java开始的包是Java核心包（Java Core Package）;</p>
<p>包名以javax开始的包是Java扩展包(Java Extension Package)，例如javax.swing包；</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><h4 id="可见性修饰符（访问控制符）"><a href="#可见性修饰符（访问控制符）" class="headerlink" title="可见性修饰符（访问控制符）"></a>可见性修饰符（访问控制符）</h4><h5 id="四个访问权限修饰符："><a href="#四个访问权限修饰符：" class="headerlink" title="四个访问权限修饰符："></a>四个访问权限修饰符：</h5><p>private：私有</p>
<p>（default）：默认</p>
<p>protected：保护</p>
<p>public：公有</p>
<p><strong>类图中表示</strong></p>
<p><img src="/image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1679990592095.png" alt="1679990592095"></p>
<h5 id="修饰符修饰的内容："><a href="#修饰符修饰的内容：" class="headerlink" title="修饰符修饰的内容："></a>修饰符修饰的内容：</h5><p>类：只有“默认”或“public”</p>
<p>成员变量和成员方法：可以为上面的四种访问权限修饰符的一种。（<strong>方法内的局部变量不可以被修饰</strong>）</p>
<h4 id="访问控制级别表"><a href="#访问控制级别表" class="headerlink" title="访问控制级别表"></a>访问控制级别表</h4><p>private：被private修饰的成员变量或成员方法只能被<strong>本类</strong>中的成员方法访问。</p>
<p>默认：前面没有任何修饰符的成员变量或成员方法，可以被本类中的成员方法或者<strong>同包</strong>中的其他类的成员方法访问。</p>
<p>protected：被protected修饰的成员变量或成员方法，可以被本类中的成员方法、同包中的其他类中的成员方法、子类中的成员方法访问。</p>
<p>public：被public修饰的成员变量或成员方法，可以被<strong>任意的类</strong>的成员方法访问。</p>
<p><img src="/image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1678949495077.png" alt="1678949495077"></p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>构造方法通常都用public修饰，除非禁止用户创建对象。</p>
<p>如Math类所有的方法都是静态的，没有必要创建对象，通过类名就可以直接调用方法。</p>
<p>成员方法通常也用public修饰，成员变量通常使用private修饰。</p>
<h2 id="给方法传递参数"><a href="#给方法传递参数" class="headerlink" title="给方法传递参数"></a>给方法传递参数</h2><p>数据类型与参数类型</p>
<ol>
<li>基本数据类型  参数传递为值，在栈里复制值</li>
<li>复合数据类型  传递引用，栈里复制引用，实参形参引用同一个对象实体</li>
</ol>
<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>使用</p>
<ol>
<li>声明  类名[] 变量名</li>
<li>初始化<ul>
<li>为数组分配内存空间  变量名 &#x3D; new 类名【数组长度】</li>
<li>为数组元素引用的对象分配内存空间  变量名[] &#x3D; new类名（参数）</li>
</ul>
</li>
<li>使用 变量名[下标]. 成员变量&#x2F;方法</li>
</ol>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><ul>
<li>作用域 仅限定义局部变量的代码块</li>
<li>初始化 使用前必须初始化</li>
<li>优先级 局部变量与成员变量重名，优先局部变量</li>
</ul>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul>
<li>作用域 在类里任意位置，都可被类内方法调用</li>
<li>初始化 可不进行初始化，系统自动完成</li>
<li>优先级 使用同名成员变量 加this</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li>关键字this是指向调用对象本身的引用名。(类似指针)</li>
</ul>
<h5 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h5><p>常在成员变量的修改器（set方法）中，引用类的隐藏数据域。</p>
<p>在一个构造方法中调用另一个构造方法。构造方法数据成员很多时，可以简化。（不能直接写：类名（））例：this(参数…)</p>
<p>  public Student(String name){</p>
<p>  this.name &#x3D; name; }</p>
<p>  public Student(String name, int age){</p>
<p>  this(name);  &#x2F;&#x2F; 只能在第一行</p>
<p>  this.age &#x3D; age;  }</p>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>只能在实例方法中使用this，而不能在类方法中使用this。</p>
<h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><p>一个JAVA项目中有很多的类，类与类之间存在如下关系：</p>
<ul>
<li>关联</li>
<li>聚集、组合</li>
<li>继承： 子类继承父类</li>
<li>实现：类实现接口</li>
</ul>
<h4 id="对象之间的关联"><a href="#对象之间的关联" class="headerlink" title="对象之间的关联"></a>对象之间的关联</h4><h5 id="对象的组合：Has-A"><a href="#对象的组合：Has-A" class="headerlink" title="对象的组合：Has-A"></a>对象的组合：Has-A</h5><p>是关联的特殊形式，描述两个对象之间的<strong>归属</strong>关系。</p>
<p>一个类的对象是另一类的数据部分</p>
<p>当类A的某个成员变量是引用类型B时，类A与类B构成Has－A的关系，描述了B是A的一部分，因此一个类A的对象将包含类B的对象。</p>
<p>类图  菱形侧为聚集类 若一对一则为涂色菱形</p>
<p><img src="/image/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1679988910649.png" alt="1679988910649"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/14/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" data-id="clrx9mt350006j4tl8k3kcwcl" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-基本数据类型和引用数据类型在内存中区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/09/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2023-03-09T06:08:29.284Z" itemprop="datePublished">2023-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/image/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8C%BA%E5%88%AB/1678342114375.png" alt="1678342114375"></p>
<p>基本数据类型</p>
<ul>
<li>只在栈内存分配空间</li>
</ul>
<p>引用数据类型 </p>
<ul>
<li>在栈内存为引用变量分配空间</li>
<li>在堆内存为对象分配空间<br>引用变量类似于指针，指向对象</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/09/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8C%BA%E5%88%AB/" data-id="clrx9mt310002j4tlckwk3g3g" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/02/%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2023-03-02T06:01:25.837Z" itemprop="datePublished">2023-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>栈 后进先出 类似地址指针</p>
<p>堆 见new 在堆开辟空间</p>
<h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>方式1 int no[];</p>
<p>方式2 int[] no;</p>
<p>注：</p>
<ol>
<li>Java数组是一种<strong>数据类型（引用数据类型）</strong>，所以建议采用“方式二”声明数组。</li>
<li><strong>定义数组时不能指定数组的长度</strong>，因为数组是一种引用类型，定义数组时，仅仅表示定义了一个引用变量（类似指针），该引用变量没有指向任何有效的内存(nul)</li>
<li>数组是引用类型，在定义完后，未指向任何有效的内存，所以值为<strong>null</strong>，在<strong>栈</strong>内存里</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote>
<p>在堆内存中，为数组元素分配内存空间，并为每个数组元素赋初始值。</p>
<p>在Java 中，使用数组时，如果为数组分配了内存空间，但是没有为数组元素指定初始值，系统会自动为数组元素指定初始值。数组元素的初始值与数组的数据类型有关，对于不同数据类型的数组，其数组元素的初始值是不一样的。下面将列举出不同类型数组元素的初始值。</p>
<p>. byte在Java 程序中使用数组时，如果没有为数组元素指定初始值，byte 型数组元素的默认初始值为0。</p>
<p>. short、. int默认初始值为0。</p>
<p>. long默认初始值为0L。</p>
<p>. float默认初始值为0.0f。</p>
<p>. double默认初始值为0.0d。</p>
<p>. char默认初始值为字符.\u.0000。</p>
<p>. boolean默认初始值为false。</p>
<p>. 引用类型(如类、接口等类型)</p>
<p>在Java 程序中使用数组时，如果没有为数组元素指定初始值，引用类型(如类、接口等类型)数组元素的默认初始值为null，例如，String 类型数组元素的默认初始值就为null。</p>
<p><img src="https://file+.vscode-resource.vscode-cdn.net/c%3A/blog/source/_posts/image/%E6%95%B0%E7%BB%84/1677765412032.png" alt="1677765412032"></p>
</blockquote>
<h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><p> 程序员指定初始值</p>
<p>no &#x3D; new int[] {1, 2, 3, 4 , 5};</p>
<p>合并声明+初始化 int[] no &#x3D; {1,2,3,4,5};</p>
<h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p> 指定长度，系统分配(分配空值)</p>
<p>no &#x3D; new int[5];</p>
<p>合并 int[] no &#x3D; new int[5]</p>
<h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>索引</p>
<p>引用长度（数组作为对象，提供length属性，该属性存储数组长度）</p>
<p>for(int i&#x3D;0;i&lt;no.length;i++)</p>
<p>{</p>
<p>}</p>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><ol>
<li>int[][] arr;</li>
<li>int arr[][];</li>
</ol>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>动态初始化</li>
</ul>
<p>用new关键词初始化（两步）</p>
<ol>
<li>数组名&#x3D;new 类型说明符[数组长度][]</li>
<li>数组名&#x3D;new 类型说明符[数组长度][数组长度]</li>
</ol>
<p><img src="/image/%E6%95%B0%E7%BB%84/1677765582494.png" alt="1677765582494"></p>
<p><img src="/image/%E6%95%B0%E7%BB%84/1678174606077.png" alt="1678174606077"></p>
<ul>
<li>静态初始化</li>
<li>注：JAVA二维数组内存存储不连续，可以看作一维数组的串联（不同于C）</li>
</ul>
<h1 id="课堂补充（非数组）：重载"><a href="#课堂补充（非数组）：重载" class="headerlink" title="课堂补充（非数组）：重载"></a>课堂补充（非数组）：重载</h1><p>对于方法：同名不同参 参数个数或者类型不同，执行哪个方法依据传入的参数而定</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/02/%E6%95%B0%E7%BB%84/" data-id="clrx9mt360007j4tlbemifkv7" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-自学笔记7运算符" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/29/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B07%E8%BF%90%E7%AE%97%E7%AC%A6/" class="article-date">
  <time class="dt-published" datetime="2023-01-29T02:43:09.000Z" itemprop="datePublished">2023-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/29/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B07%E8%BF%90%E7%AE%97%E7%AC%A6/">自学笔记7运算符</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p><strong>算数运算符</strong>** + - * &#x2F; &#x2F;&#x2F; % **<br>注:&#x2F; 整数相除结果为整数，因为最高类型为整数</p>
</li>
<li><p>“+”与字符串运算时作连接符，结果为字符串</p>
</li>
<li><p><strong>比较运算符</strong> &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;</p>
</li>
<li><p><strong>赋值运算符</strong>&#x3D;  +&#x3D;   -&#x3D;  *&#x3D;   &#x2F;&#x3D;   &#x2F;&#x2F;&#x3D;  %&#x3D;    **&#x3D;</p>
</li>
<li><p><strong>成员运算符：in 和 not in （针对于容器类型数据）</strong></p>
</li>
<li><p><strong>身份运算符</strong> ： is和 is not（检测两个数据在内存当中是否是同一个值）</p>
</li>
<li><p><strong>逻辑运算符</strong> : and or not</p>
</li>
<li><p><strong>位运算符</strong> &amp; | ^ &lt;&lt; &gt;&gt; ~</p>
</li>
<li><p>条件运算符(? : )是一个三目运算符，即有三个操作数。</p>
<p> 使用条件运算符（?:）可以实现 If else 的功能，其一般形式为：</p>
<p> 表达式1 ? 表达式2 : 表达式3</p>
<p> 其意思是：如果表达式1为真，则运算表达式2，整个条件表达式的值为 表达式2的值；反之，则运算表达式3，整个条件表达式的值为表达式3的值。</p>
</li>
</ul>
<p><img src="/image/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B07%E8%BF%90%E7%AE%97%E7%AC%A6/1685279962960.png" alt="1685279962960"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/29/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B07%E8%BF%90%E7%AE%97%E7%AC%A6/" data-id="clrx9mt3c0009j4tl5pf86xea" data-title="自学笔记7运算符" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/28/%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86/">我回来了</a>
          </li>
        
          <li>
            <a href="/2023/09/04/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/27/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/26/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E7%B1%BB%E5%9E%8B%E5%A4%A7%E7%BA%B2/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/18/%E5%BC%82%E5%B8%B8/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 missbyebye<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>